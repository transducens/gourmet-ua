from os.path import join

#Output dirs
permanentDir = config["permanentDir"]
corpusDir = permanentDir + "/corpus"
evalDir = permanentDir + "/eval"
modelDir = permanentDir + "/model"

marian=config["marianDir"]
moses=config["mosesDir"]
subword_nmt=config["subwordNmtDir"]
tools=config["toolsDir"]

bpeModel=config["bpeModel"]
externalVocab=config["externalVocab"]
externalTruecasers=config["externalTruecasers"]
addMark=config["addMark"]

ssuffix=config["ssuffix"]
wwMark=config["wwMark"]

LANG1=config["lang1"]
LANG2=config["lang2"]

tokenizer_l1 = moses + "/scripts/tokenizer/normalize-punctuation.perl -l " + LANG1 + " | " + moses + "/scripts/tokenizer/tokenizer.perl -a -l " + LANG1
tokenizer_l2 = moses + "/scripts/tokenizer/normalize-punctuation.perl -l " + LANG2 + " | " + moses + "/scripts/tokenizer/tokenizer.perl -a -l " + LANG2
detokenizer = moses + "/scripts/tokenizer/detokenizer.perl -l " + LANG2

sentenceSplitter1 = moses + "/scripts/ems/support/split-sentences.perl -b -l " + LANG1
sentenceSplitter2 = moses + "/scripts/ems/support/split-sentences.perl -b -l " + LANG2

#NMT commands
trainCmd = "{0}/build/marian -d {1} ".format(marian, config["gpuId"]) + " ".join(config["marianArgs"]) + " --valid-log " + permanentDir +"/valid.log --log " + permanentDir + "/train.log"

translateCmd = "{0}/build/marian-decoder --max-length-crop -d {1} --quiet-translation --max-length 100".format(marian, config["gpuId"])

bleuCmd = moses + "/scripts/generic/multi-bleu-detok.perl"

#Input data prefixes
trainPrefixes=config["initCorpusTrainPrefix"]
devPrefix=config["initCorpusDevPrefix"]
testPrefixes=config["initCorpusTestPrefix"]
assert(len(devPrefix) == 1)

############################################# EVALUATION #############################################################

def allTestNames(dataset):
    names = []
    for f in dataset:
        names.append(os.path.basename(f))
    return names

rule report:
    input:
        expand(evalDir+"/{name}.bleu", name=allTestNames(testPrefixes))
    output:
        evalDir+"/report"
    run:
        with open(output[0], "wt") as outHandle:
            for file in input:
                with open(file, "rt") as inHandle:
                    str = inHandle.read()
                    outHandle.write(os.path.basename(file).replace(".bleu",""))
                    outHandle.write("\t")
                    outHandle.write(str)

rule multibleu:
    input:
        trans=evalDir+"/{name}.output.detokenized"
        ,
        ref=corpusDir+"/{name}."+"{lang}".format(lang=LANG2)
    output:
        evalDir+"/{name}.bleu"
    shell:
        "cat {input.trans} | {bleuCmd} {input.ref} > {output}"

rule translate_only:
    input:
        trans=evalDir+"/in.output.detokenized"

    output:
        evalDir+"/output"
    shell:
      	#"hostname;"
        "cp {input} {output}"

##########################################  RUNNING MT ENGINE ##########################################


rule translate_test:
    input:
        modelPrevious="{dir}/marian/model.npz.decoder.yml".format(dir=modelDir)
        ,
        test=corpusDir+"/{name}.bpe." + "{lang}".format(lang=LANG1),
        test2s=corpusDir+"/{name}.bpe." + "{lang}.2s".format(lang=LANG2)
    output:
        evalDir+"/{name}.output"
    params:
        model="{dir}/marian/{modelFile}".format(dir=modelDir, modelFile=config["marianModelFile"])

    shell:
        "{translateCmd} -i {input.test} {input.test2s} -c {params.model} > {output}"

rule train_nmt:
    input:
        vocab=modelDir+"/vocab."+LANG1+LANG2+".yml",
        train=[corpusDir+"/train.clean-bpe.{lang}".format(lang=LANG1),
               corpusDir+"/train.clean-bpe.{lang}.2s".format(lang=LANG2),
               corpusDir+"/train.clean-bpe.{lang}".format(lang=LANG2)]
        ,
        valid=[corpusDir+"/dev.bpe.{lang}".format(lang=LANG1),
               corpusDir+"/dev.bpe.{lang}.2s".format(lang=LANG2),
               corpusDir+"/dev.bpe.{lang}".format(lang=LANG2)]

    output:
        "{dir}/marian/model.npz.decoder.yml".format(dir=modelDir)
    shell:
        "{trainCmd} -t {input.train} --valid-sets {input.valid} --vocabs {input.vocab} {input.vocab} {input.vocab}  -m {modelDir}/marian/model.npz"

################################################## MARIAN VOCAB ################################################################

rule make_vocab_yml:
    input:
        externalVocab
    output:
        modelDir+"/vocab.{lang1}{lang2}.yml".format(lang1=LANG1,lang2=LANG2)
    shell:
        "cat {input}   > {output}"

####################################################### TRUECASE ###########################################################

ruleorder: apply_truecaser_2s > apply_truecaser

rule apply_truecaser:
    input:
        file='{name}.tok.{lang}'
    output:
        '{name}.tc.{lang}'
    params:
        tModel=lambda w: externalTruecasers[w.lang]
    shell:
        "cat {input.file} | {moses}/scripts/recaser/truecase.perl -model {params.tModel} > {output}"


rule apply_truecaser_2s:
    input:
        file='{name}.tok.{lang}.2s'
    output:
        '{name}.tc.{lang}.2s'
     params:
         tModel=lambda w: externalTruecasers[w.lang]
    shell:
        "cat {input.file} | {moses}/scripts/recaser/truecase.perl -model {params.tModel} > {output}"


ruleorder: apply_truecaser_train_2s > apply_truecaser_train

rule apply_truecaser_train:
    input:
        file='{name}.clean.{lang}'
    output:
        '{name}.clean-tc.{lang}'
    params:
        tModel=lambda w: externalTruecasers[w.lang]
    shell:
        "cat {input.file} | {moses}/scripts/recaser/truecase.perl -model {params.tModel} > {output}"

rule apply_truecaser_train_2s:
    input:
        file='{name}.clean.{lang}.2s'
    output:
        '{name}.clean-tc.{lang}.2s'
    params:
        tModel=lambda w: externalTruecasers[w.lang]
    shell:
        "cat {input.file} | {moses}/scripts/recaser/truecase.perl -model {params.tModel} > {output}"

####################################################### CLEAN ###########################################################

rule clean:
    input:
        l1="{pref}.tok."+"{lang1}".format(lang1=LANG1)
        ,
        l2="{pref}.tok."+"{lang2}".format(lang2=LANG2),
        l2s="{pref}.tok."+"{lang2}.2s".format(lang2=LANG2)
    output:
        l1="{pref}.clean."+"{lang1}".format(lang1=LANG1)
        ,
        l2="{pref}.clean."+"{lang2}".format(lang2=LANG2),
        l2s="{pref}.clean."+"{lang2}.2s".format(lang2=LANG2)
    shell:
        "{moses}/scripts/training/clean-corpus-n.perl {wildcards.pref}.tok {LANG1} {LANG2} {wildcards.pref}.clean 1 80 {wildcards.pref}.lines-retained; python3 {tools}/filter-lines-retained.py {wildcards.pref}.lines-retained < {input.l2s}  >{output.l2s}"

####################################################### TOKENIZE ###########################################################

rule tokenize_file_l1:
    input:
        "{pref}."+"{lang}".format(lang=LANG1)
    output:
        "{pref}.tok."+"{lang}".format(lang=LANG1)
    shell:
        "cat {input} | {tokenizer_l1} > {output}"

rule tokenize_file_l2:
    input:
        "{pref}."+"{lang}".format(lang=LANG2)
    output:
        "{pref}.tok."+"{lang}".format(lang=LANG2)
    shell:
        "cat {input} | {tokenizer_l2} > {output}"

rule tokenize_file_l2_2s:
    input:
        "{pref}."+"{lang}.2s".format(lang=LANG2)
    output:
        "{pref}.tok."+"{lang}.2s".format(lang=LANG2)
    shell:
        "cat {input} | {tokenizer_l2} > {output}"


####################################################### POSTPROCESSING ###########################################################

rule detok:
    input:
        "{pref}.output.detruecased"
    output:
        "{pref}.output.detokenized"
    shell:
        "cat {input} | {detokenizer} > {output}"

rule detruecase:
    input:
        "{pref}.output.debpe"
    output:
        "{pref}.output.detruecased"
    shell:
        "cat {input} | {moses}/scripts/recaser/detruecase.perl > {output}"

rule debpe:
    input:
        "{pref}.output"
    output:
        "{pref}.output.debpe"
    shell:
        "cat {input} | sed -r 's/(@@ )|(@@ ?$)//g' > {output}"

##################################### MORPHOLOGICAL SEGMENTATION ##################

ruleorder: morph_segment_2s > morph_segment

rule morph_segment:
    input:
        '{name}tc.{lang}'
    output:
        '{name}tc.seg.{lang}'
    params:
        sModel=lambda w: segModel[w.lang]
    shell:
        "if [ '{params.sModel}' != ''  ]; then bash {smartSegmentation}/segment.sh -c {input} -m {params.sModel} -l {wildcards.lang} {segParams}  > {output} ; else cp {input} {output}  ;  fi"

rule morph_segment_2s:
    input:
        '{name}tc.{lang}.2s'
    output:
        '{name}tc.seg.{lang}.2s'
    params:
        sModel=lambda w: segModel[w.lang]
    shell:
        "if [ '{params.sModel}' != ''  ]; then bash {smartSegmentation}/segment.sh -c {input} -m {params.sModel} -l {wildcards.lang} {segParams}  > {output} ; else cp {input} {output}  ;  fi"

############################################## BPE #################################

rule apply_bpe_test:
    input:
        file="{pref}.tc.seg.{lang}"
        ,
        vocab=bpeModel
    output:
        "{pref}.bpe.{lang}"
    params:
         mark=lambda w: addMark[w.lang]
    shell:
        "{subword_nmt}/subword_nmt/apply_bpe.py --glossaries {wwMark} -c {input.vocab} < {input.file} | sed 's: ￭:@@ :g' |  {{ if [ \"{params.mark}\" != \"\" ]; then  sed 's:^:{params.mark} :' ; else cat -;  fi  }}  > {output}"

rule apply_bpe_train:
    input:
        file="{pref}.clean-tc.seg.{lang}"
        ,
        vocab=bpeModel
    output:
        "{pref}.clean-bpe.{lang}"
    params:
         mark=lambda w: addMark[w.lang]
    shell:
        "{subword_nmt}/subword_nmt/apply_bpe.py --glossaries {wwMark} -c {input.vocab} < {input.file} | sed 's: ￭:@@ :g' |  {{ if [ \"{params.mark}\" != \"\" ]; then  sed 's:^:{params.mark} :' ; else cat -;  fi  }}  > {output}"

###################################### PREPARE DATA ##############################################

rule prepare_traindata:
    input:
         l1=expand("{dataset}.{lang}", dataset=trainPrefixes, lang=LANG1)
         ,
         l2=expand("{dataset}.{lang}", dataset=trainPrefixes, lang=LANG2),
         l2s=expand("{dataset}.{lang}.{suf}", dataset=trainPrefixes, lang=LANG2,suf=ssuffix)
    output:
         l1=corpusDir+"/train.{lang}".format(lang=LANG1)
         ,
         l2=corpusDir+"/train.{lang}".format(lang=LANG2),
	 l2s=corpusDir+"/train.{lang}.2s".format(lang=LANG2)
    shell:
         "mkdir -p {corpusDir}; cat {input.l1} > {output.l1} && cat {input.l2} > {output.l2} && cat  {input.l2s} > {output.l2s}"

rule prepare_devdata:
    input:
         l1=expand("{dataset}.{lang}", dataset=devPrefix, lang=LANG1)
         ,
         l2=expand("{dataset}.{lang}", dataset=devPrefix, lang=LANG2),
         l2s=expand("{dataset}.{lang}.{suf}", dataset=devPrefix, lang=LANG2,suf=ssuffix)
    output:
         l1=corpusDir+"/dev.{lang}".format(lang=LANG1)
         ,
         l2=corpusDir+"/dev.{lang}".format(lang=LANG2),
         l2s=corpusDir+"/dev.{lang}.2s".format(lang=LANG2)
    shell:
         "mkdir -p {corpusDir}; cat {input.l1} > {output.l1} && cat {input.l2} > {output.l2} && cat {input.l2s} > {output.l2s}"

rule prepare_test:
    input:
         l1=expand("{dataset}.{lang}", dataset=testPrefixes, lang=LANG1)
         ,
         l2=expand("{dataset}.{lang}", dataset=testPrefixes, lang=LANG2),
         l2s=expand("{dataset}.{lang}.{suf}", dataset=testPrefixes, lang=LANG2,suf=ssuffix)
    output:
         l1=expand(corpusDir+"/{name}.{lang}", name=allTestNames(testPrefixes), lang=LANG1)
         ,
         l2=expand(corpusDir+"/{name}.{lang}", name=allTestNames(testPrefixes), lang=LANG2),
         l2s=expand(corpusDir+"/{name}.{lang}.2s", name=allTestNames(testPrefixes), lang=LANG2)
    shell:
         "mkdir -p {corpusDir}; cp -r {input.l1} {input.l2}  {corpusDir}; cp {input.l2s} {output.l2s}"

rule prepare_translate_only:
    input:
         l1="in"
    output:
         corpusDir+"/in.{lang}".format(lang=LANG1)
    shell:
         "cp {input} {output}"
